#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>

// GraalVM Native Image shared library header (generated by native-image --shared)
#include "sdk_runtime.h"

// webview (single-header, uses native OS WebView)
#include "webview.h"

// Embedded UI assets -- generated at build time by embed_assets.py
#include "embedded_assets.h"

// ─── GraalVM isolate globals ────────────────────────────────────────────────
static graal_isolate_t*       isolate = nullptr;
static graal_isolatethread_t* thread  = nullptr;

// ─── JSON string extraction ────────────────────────────────────────────────
// Extracts JSON string values from an array like: ["route","payload"]
// Handles escaped quotes (\") and escaped backslashes (\\) correctly.
static std::vector<std::string> json_extract_strings(const std::string& json) {
    std::vector<std::string> results;
    size_t i = 0;
    while (i < json.size()) {
        // Find the opening quote of the next string
        if (json[i] == '"') {
            std::string value;
            ++i;
            while (i < json.size() && json[i] != '"') {
                if (json[i] == '\\' && i + 1 < json.size()) {
                    char next = json[i + 1];
                    switch (next) {
                        case '"':  value += '"';  break;
                        case '\\': value += '\\'; break;
                        case 'n':  value += '\n'; break;
                        case 'r':  value += '\r'; break;
                        case 't':  value += '\t'; break;
                        case '/':  value += '/';  break;
                        default:   value += '\\'; value += next; break;
                    }
                    i += 2;
                } else {
                    value += json[i];
                    ++i;
                }
            }
            ++i; // skip closing quote
            results.push_back(std::move(value));
        } else {
            ++i;
        }
    }
    return results;
}

// ─── IPC: called when JS invokes window.lumina.send(route, payload) ─────────
//
// webview.bind dispatches the JS params array as a JSON string.
// For send(route, payload) this arrives as: ["route","payload"]
// We parse both strings and forward them to the Java backend.
//
static void lumina_ipc_handler(const std::string& seq,
                               const std::string& req,
                               void*              userdata) {
    auto* w = static_cast<webview::webview*>(userdata);

    auto args = json_extract_strings(req);

    std::string route   = args.size() > 0 ? args[0] : "";
    std::string payload = args.size() > 1 ? args[1] : "{}";

    if (route.empty()) {
        w->resolve(seq, 1, R"({"error":"empty_route"})");
        return;
    }

    // Call into the GraalVM-compiled Java library
    char* response = lumina_handle_request(thread,
                                           const_cast<char*>(route.c_str()),
                                           const_cast<char*>(payload.c_str()));

    std::string result(response ? response : "{}");

    // Free the unmanaged memory allocated on the Java side
    if (response) {
        lumina_free_string(thread, response);
    }

    // Resolve the JS promise with the Java response.
    // webview.resolve() injects result directly into: window._rpc[seq].resolve(<result>)
    // The result must be a valid JS expression. JSON objects from Java are safe because
    // JSON is a subset of JS expression syntax.
    w->resolve(seq, 0, result);
}

// ─── Parse --dev flag ───────────────────────────────────────────────────────
static bool has_flag(int argc, char* argv[], const char* flag) {
    for (int i = 1; i < argc; i++) {
        if (std::strcmp(argv[i], flag) == 0) return true;
    }
    return false;
}

// ─── Entry point ────────────────────────────────────────────────────────────
int main(int argc, char* argv[]) {
    bool dev_mode = has_flag(argc, argv, "--dev");

    if (!dev_mode) {
        // 1. Create a GraalVM isolate (lightweight VM context)
        if (graal_create_isolate(nullptr, &isolate, &thread) != 0) {
            std::fprintf(stderr, "lumina: failed to create GraalVM isolate\n");
            return 1;
        }
    }

    // 2. Create the native webview window
    //    Dev mode: enable DevTools for debugging
    webview::webview w(/*debug=*/dev_mode, nullptr);
    w.set_title(dev_mode ? "Lumina App (Dev)" : "Lumina App");
    w.set_size(1024, 768, WEBVIEW_HINT_NONE);

    if (!dev_mode) {
        // 3. Bind the raw IPC transport. webview.bind() wraps this in a JS Promise:
        //    JS calls __lumina_send(route, payload) → returns Promise<string>
        //    webview serializes args as JSON array → C++ callback → resolve/reject
        w.bind("__lumina_send", lumina_ipc_handler, &w);

        // 4. Inject the public JS API. Wraps the raw binding with a developer-facing
        //    interface and guarantees the response is parsed from JSON.
        w.init(R"JS(
            window.lumina = {
                send: function(route, payload) {
                    if (typeof route !== 'string' || !route) {
                        return Promise.reject(new Error('lumina.send: route must be a non-empty string'));
                    }
                    return __lumina_send(route, typeof payload === 'string' ? payload : JSON.stringify(payload || {}))
                        .then(function(raw) {
                            try { return JSON.parse(raw); }
                            catch(e) { return raw; }
                        });
                }
            };
        )JS");

        // 5. Load UI from embedded assets (index.html as a data URI)
        std::string html(reinterpret_cast<const char*>(LUMINA_INDEX_HTML),
                         LUMINA_INDEX_HTML_LEN);
        w.set_html(html);
    } else {
        // Dev mode: navigate to Vite dev server.
        // The JS dev bridge in main.ts handles IPC via fetch to DevServer.
        w.navigate("http://localhost:5173");
    }

    // 6. Run the event loop (blocks until window is closed)
    w.run();

    if (!dev_mode) {
        // 7. Tear down the GraalVM isolate
        graal_tear_down_isolate(thread);
    }

    return 0;
}
